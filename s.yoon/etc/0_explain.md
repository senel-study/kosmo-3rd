# 넥슨

```python
sum(set(range(1, 50)) - {x + sum([int(a) for a in str(x)]) for x in range(1, 50)})
```

문제는 5000까지지만 연산의 속도를 위해 50으로 줄여놓아보았다.

해석을 위해선 식을 분해할 필요가있다.

`sum( ~ )` : 가장 바깥쪽의 sum은 모든 셀프 넘버들 합을 구하기 위해 존재.

`set(range(1, 50))` : 1에서 50까지의 숫자를 집합으로 저장한다.

`{x + sum([int(a) for a in str(x)]) for x in range(1, 50)}`  

람다식이다.

제네레이터의 공식이 `자릿수들의 합 + 자기자신`이므로 맨 앞의 x는 자기자신이다.

`sum([int(a) for a in str(x)]) for x in range(1, 50)`을 보면 람다식의 반복문 중첩인데, 숫자 전체를 돌리는 바깥쪽의 반복문(이 때 문자열화를 한다.) 안의 반복문은 문자열의 각 자릿수를 다시 숫자화해서 sum을 한다.

그리고 가장 바깥쪽의 반복문은 x를 1부터 50까지 돌리는 반복문.

람다식으로 하면 반복문의 중첩이 참 쉬워지는 듯.

그리고 가장 연산이 끝난 것을 {}로 감싸 집합자료형으로 만든다.

자동으로 중복이 제거되고 차집합연산으로 깔끔하게 결과가 도출된다.