# 입사 문제 조각들

## 넥슨

```python
sum(set(range(1, 50)) - {x + sum([int(a) for a in str(x)]) for x in range(1, 50)})
```

문제는 5000까지만 연산의 속도를 위해 50으로 줄여놓아보았다.

해석을 위해선 식을 분해할 필요가있다.

`sum( ~ )` : 가장 바깥쪽의 sum은 모든 셀프 넘버들 합을 구하기 위해 존재.

`set(range(1, 50))` : 1에서 50까지의 숫자를 집합으로 저장한다.

`{x + sum([int(a) for a in str(x)]) for x in range(1, 50)}`  

람다식이다.

제네레이터의 공식이 `자릿수들의 합 + 자기자신`이므로 맨 앞의 x는 자기자신이다.

`sum([int(a) for a in str(x)]) for x in range(1, 50)`을 보면 람다식의 반복문 중첩인데, 숫자 전체를 돌리는 바깥쪽의 반복문(이 때 문자열화를 한다.) 안의 반복문은 문자열의 각 자릿수를 다시 숫자화해서 sum을 한다.

그리고 가장 바깥쪽의 반복문은 x를 1부터 50까지 돌리는 반복문.

람다식으로 하면 반복문의 중첩이 참 쉬워지는 듯.

그리고 가장 연산이 끝난 것을 {}로 감싸 집합자료형으로 만든다.

자동으로 중복이 제거되고 차집합연산으로 깔끔하게 결과가 도출된다.

---

## Google

### 카운트

`[1,2,3,...]`

이 리스트의 모양을 그대로 문자화시켜서 8을 셈

### 스페셜 소트

람다..람다..

### Samllest Range

가설

1. k개의 리스트 가장 작은 값들을 모아 새로운 리스트(heap)로 만든다.

2. heap리스트에서 길이와 범위 기록한다.

3. 가장 작은 숫자를 지우고, 그 숫자가 속해있던 리스트에서 그 다음으로 작은 숫자를 heap에 추가한다.

4. 길이를 체크하고 더 작을 경우 갱신

5. k개의 리스트 중 하나의 리스트가 완전히 비어버리면 중단.

---

## Daum

정렬이 되어 있다는 가정이라 한자리씩 비교하면 되는데 좀 더 효율이 좋은 로직은 없는가..?

---

## 사이냅

특별히 어려운 것이 없음.

사전작업 : `,`를 기준으로 리스트화

1번문제 : 정규식 `r'^김|이'`으로 맞는 갯수 카운트

2번문제 : 1번으로 추려낸 리스트에서 `이재영` 카운트

3번문제 : `list(set(obj))` 으로 깔끔하게 중복 제거

4번문제 : `list.sort()`
